---
layout: post
title: "算法基础-交换排序之冒泡排序"
date: 2014-07-30 08:59:01.000000000 +08:00
type: post
published: true
status: publish
categories:
- Technology
tags:
- Algorithm
- BubbleSort
meta:
  _edit_last: '1'
---
<h3>原理：</h3>
<p>交换排序也是排序算法的一种，它与插入排序不同的是，它是每次将两个数据进行交换，而不是分成两组，排序组与未排序组。经典的交换排序有快速排序（Quick Sort）和冒泡排序（Bubble Sort），这里先说冒泡排序。冒泡排序是每次排列都会将一个数据按升序或者降序排到最后或者最前面，所以每次排序都会使一个数在最大或者最小的位置。按升序来说，具体是每次让最起始数据与紧挨它后面的数据比较，大的话就交换位置，然后依次执行下去，最终一定会有一个最大的数据排到最后。循环最后， 当数据没有任何交换动作时，说明所有数据排列完毕，退出循环。整个过程像冒泡一样，所以叫冒泡排序。</p>
<p>下面的算法是先让最小的数据到数据的0号初始位置。</p>
<!--more-->
<h3>算法：</h3>
<pre>int temp;
for(int i = 0;i &lt; count;i++) {
    flag = 0;
    for(int j = count - 1;j &gt; i;j--) {
        if(Array[j - 1] &gt; Array[j]) {
            temp = Array[j];
            Array[j] = Array[j - 1];
            Array[j - 1] = temp;
            flag = 1;
        }
    }
    if(flag == 0) 
        return;// Exit
}</pre>
<h3>稳定性：</h3>
<p>冒泡算法是一种稳定的算法，当两个数据值相同时，并不交换位置。</p>
<h3>复杂度：</h3>
<p>考虑最坏情况，整个数据都是降序排列的，而要排到升序，此时将执行N * N次，所以时间复杂度为o(n^2)，空间复杂度为o(1)。</p>
<h3>优缺点：</h3>
<p>冒泡算法效率并不高，每次直接交换数据将会造成较大开销，虽然时间复杂度与直接插入算法相同，但实际实行起来效率要更低一些。</p>
<h3>测试：</h3>
<p>100000的数据量，平均排序时间为25700 ms，语言为Javascript，这比用C语言写的效率要差很多。测试环境与之前的一样。</p>
